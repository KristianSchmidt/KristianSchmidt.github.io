---
layout: post
title: Testing  
---

This post is part of the [F# Advent Calendar 2016](https://sergeytihon.wordpress.com/2016/10/23/f-advent-calendar-in-english-2016/). Check it out for two F# blog posts a day for the whole month of December. And special thanks to [Sergey Tihon](https://twitter.com/sergey_tihon) for organizing this!

What the most efficient way to get the F# community into the christmas spirit? Someone using F# in production, surely.
So today I'm going to give a little intro to our latest project, and reflect a bit on the challenges we faced. 

<!--more-->

## Intro

I work at [PFA Pension](https://www.pfa.dk) in the actuarial modelling department, where our primary task is to calculate the total liabilities for the company's insurance policies. The liability is the amount of money we need to set aside to be sure that we're able to pay our obligations to the customers.

I have [previously spoken](http://www.kreutz.us/2016/01/20/slides-from-my-talk-at-mf-k/) about how we've used F# to calculate the value of individual contracts. This is the extension of that work, in which we consider entire policies consisting of multiple contracts. So where calculating the value of one contract was math heavy, this project's focus is more on implementing business rules and taming the complexity of these, along with fleshing out the structure of the problem domain in types.

## The Existing Solution

Pension companies having to calculate liabilities is nothing new, and we already had an existing solution in place. This was written in the SAS statistical programming language. For those of you that, thankfully, don't know about it, SAS is a row-based data-processing language, where you write a function (a so called data-step) to process each row of a table.

As you might imagine, this makes a lot of common tasks needlessly hard. To make matters worse, the main abstraction is a macro, which is just like a function, except it's just directly inserted into your code. So you have to be careful not to use the same variable names from your macros in your other code. Oh, and did I mention that all variables are global?

People often shun the big rewrite, but in our case, we were at a place where no one wanted to change the existing code in fear of what might happen. We were also using a language that was generating additional complexity instead of limiting it. So, for me at least, it was a no brainer.

## Getting Data

To compute anything we need to get some data into an appropriate model. Here we make extensive use of [Railway-oriented-programming](http://fsharpforfunandprofit.com/rop/), which enables us to streamline the error prone process of parsing data. 

Let's look at a little, example.

```fsharp
type DataRecord = { PropX : X; PropY : Y }

type Error = | XError of string | YError of string

type Result<'a> = | OK of 'a | Failure of Error

let readX : X = function
                | "1" -> OK X1
                | "2" -> OK X2
                | s   -> Failure (XError <| sprintf "Unknown X type %s" s)

let readY = ...

let example xStr yStr =
    data {
        let! x = readX xStr
        let! y = readY yStr

        return { PropX = x; PropY = y }
    }
```

Here we're able to contain the error handling logic in individual, small, functions and then compose them with our *data* computation expression, which just makes sure none of the *let!* bindings return *Failure*, returning the first failure if there are any.

Not only does this make for a relatively pleasant experience doing data parsing. This also allowed us 

<!--
Description of AAA

Intro:
General introduction
Previous presentation about DASK
Description of the problem, going from SAS to F#.
SAS only has globals and macros => house of cards ready to tumble

Debugging made easy with the REPL. Being able to load up a single policy and call library functions on it. Mention deedle frames.

Result type - Railway oriented programming

Immutability is king

Beware of easy string translations

Performance in general.
GC stats, being allocation bound because of immutability

Testing. Mostly doing a full test. Good unit tests hard to implement for many business rules.
-->




